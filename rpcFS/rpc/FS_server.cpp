/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "FS.h"
#include "../src/mainFS.h"
#include"../src/Kernel.h"
#include"../src/User.h"
#include"../src/FileManager.h"
#include <stdio.h>
#include <string.h>

void *
init_1_svc(void *argp, struct svc_req *rqstp)
{
	static char * result;

	/*
	 * insert server code here
	 */
	myfs_InitSystem();
	return (void *) &result;
}


GetcurSetnoerr_re *
getcursetnoerr_1_svc(void *argp, struct svc_req *rqstp)
{
	static GetcurSetnoerr_re  result;

	/*
	 * insert server code here
	 */
	User *u = &Kernel::Instance().GetUser();
	u->u_error = User::MYNOERROR;

	strcpy(result.name,u->u_curdir);

	return &result;
}


Ls_re *
ls_1_svc(void *argp, struct svc_req *rqstp)
{
	static Ls_re  result;
	memset(result.name,0,sizeof(result.name));

	/*
	 * insert server code here
	 */
	User *u = &Kernel::Instance().GetUser();

	u->u_ar0 = 0;
	myfs_Fopen(u->u_curdir, File::FREAD);
	int fd = u->u_ar0;
	
	char buffer[32] = {0};
	
	while (1)
	{
		myfs_Fread(fd, buffer, 32);
		
		if (u->u_ar0 == 0)
		    break;
		else
		{
		    DirectoryEntry *de = (DirectoryEntry *)buffer;
		    if (de->m_ino == 0)
			continue;
		    if(strcmp(de->m_name,"..")==0 || strcmp(de->m_name,".")==0){
			continue;
		    }
		    //printf("%s ", de->m_name);
		    strcat(result.name,de->m_name);
		    strcat(result.name," ");
		    memset(buffer, 0, 32);
		}
	}
	myfs_Fclose(fd);
	return &result;
}

Fopen_re *
fopen_1_svc(Fopen_s *argp, struct svc_req *rqstp)
{
	static Fopen_re  result;
	memset(result.reMessage,0,sizeof(result.reMessage));
	result.fd = 0;
	/*
	 * insert server code here
	 */
	User *u = &Kernel::Instance().GetUser();

	char name[50];
	int mode = File::FREAD | File::FWRITE;
	strcpy(name,argp->name);
	myfs_Fopen(name, mode);
    
	if (u->u_error != User::MYNOERROR){
		sprintf(result.reMessage,"fopen: error!\n");
		result.fd = -1;
	}
	else{
		sprintf(result.reMessage,"fopen: return fd:%d\n", u->u_ar0);
		result.fd = u->u_ar0;
	}
	return &result;
}

Fclose_re *
fclose_1_svc(Fclose_s *argp, struct svc_req *rqstp)
{
	static Fclose_re  result;
	memset(result.reMessage,0,sizeof(result.reMessage));
	/*
	 * insert server code here
	 */
	User *u = &Kernel::Instance().GetUser();

	int fd = argp->fd;
	myfs_Fclose(fd);
	
        if (u->u_error != User::MYNOERROR)
		sprintf(result.reMessage,"fclose: error!\n");
	else
		sprintf(result.reMessage,"fclose: fd:%d is closed.\n", fd);

	return &result;
}

Fread_re *
fread_1_svc(Fread_s *argp, struct svc_req *rqstp)
{
	static Fread_re  result;
	memset(result.x,0,sizeof(result.x));
	result.count = 0;
	/*
	 * insert server code here
	 */
	User *u = &Kernel::Instance().GetUser();
	
	int fd,length;
	fd = argp->fd;
	length = argp->length;
	myfs_Fread(fd,result.x,length);
	//for(int i=0;i<strlen(result.x);i++){
	//	printf("%hx ",(unsigned short)(result.x[i]));
	//}
	result.count = u->u_ar0;

	return &result;
}

Fwrite_re *
fwrite_1_svc(Fwrite_s *argp, struct svc_req *rqstp)
{
	static Fwrite_re  result;
	memset(result.reMessage,0,sizeof(result.reMessage));
	result.count = 0;
	/*
	 * insert server code here
	 */
	User *u = &Kernel::Instance().GetUser();

	
	int fd;
	char buffer[1024];
	int length;
	fd = argp->fd;
	memcpy(buffer,argp->x,1024);
	length = argp->length;
	myfs_Fwrite(fd, buffer,length);
	
	sprintf(result.reMessage,"fwrite: write %d chars\n", u->u_ar0);
	result.count = u->u_ar0;

	return &result;
}

Flseek_re *
flseek_1_svc(Flseek_s *argp, struct svc_req *rqstp)
{
	static Flseek_re  result;
	memset(result.reMessage,0,sizeof(result.reMessage));
	/*
	 * insert server code here
	 */
	User *u = &Kernel::Instance().GetUser();

	int fd;
	int pos;
	int mode = 0;
	fd = argp->fd;
	pos = argp->pos;
	myfs_Flseek(fd, pos, mode);

	return &result;
}

Fcreate_re *
fcreate_1_svc(Fcreate_s *argp, struct svc_req *rqstp)
{
	static Fcreate_re  result;
	memset(result.reMessage,0,sizeof(result.reMessage));
	result.fd = 0;
	/*
	 * insert server code here
	 */
	User *u = &Kernel::Instance().GetUser();

	char name[50];
	int mode = 7 | (7<<3)|(7<<6); //文件类型为普通数据文件00
	strcpy(name,argp->name);
	myfs_Fcreate(name,mode);
	sprintf(result.reMessage,"fcreat: return fd:%d\n", u->u_ar0);
	result.fd = u->u_ar0;
	return &result;
}

Mkdir_re *
mkdir_1_svc(Mkdir_s *argp, struct svc_req *rqstp)
{
	static Mkdir_re  result;
	memset(result.reMessage,0,sizeof(result.reMessage));
	/*
	 * insert server code here
	 */
	User *u = &Kernel::Instance().GetUser();

	char name[50];
	strcpy(name,argp->name);
	myfs_Mkdir(name);
	
	return &result;
}

Fdelete_re *
fdelete_1_svc(Fdelete_s *argp, struct svc_req *rqstp)
{
	static Fdelete_re  result;
	memset(result.reMessage,0,sizeof(result.reMessage));
	/*
	 * insert server code here
	 */
	User *u = &Kernel::Instance().GetUser();

	char name[50];
	strcpy(name,argp->name);
	myfs_Fdelete(name);
	if (u->u_error != User::MYNOERROR)
		sprintf(result.reMessage,"fdelete: error!\n");
	else
		sprintf(result.reMessage,"fdelete: success.\n", u->u_ar0);
	return &result;
}

Cd_re *
cd_1_svc(Cd_s *argp, struct svc_req *rqstp)
{
	static Cd_re  result;
	memset(result.reMessage,0,sizeof(result.reMessage));
	/*
	 * insert server code here
	 */
	User *u = &Kernel::Instance().GetUser();

	char name[50];
	strcpy(name,argp->name);
	myfs_Cd(name);
	if (u->u_error != User::MYNOERROR)
		sprintf(result.reMessage,"cd: error!\n");
	return &result;
}

Shutdown_re *
shutdown_1_svc(void *argp, struct svc_req *rqstp)
{
	static Shutdown_re  result;

	/*
	 * insert server code here
	 */
        FileSystem *fileSystem = &Kernel::Instance().GetFileSystem();
        fileSystem->Update();

	return &result;
}
