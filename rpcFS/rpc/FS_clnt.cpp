/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <memory.h> /* for memset */
#include "FS.h"

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

void *
init_1(void *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, Init,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

GetcurSetnoerr_re *
getcursetnoerr_1(void *argp, CLIENT *clnt)
{
	static GetcurSetnoerr_re clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, GetcurSetnoerr,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_GetcurSetnoerr_re, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

Ls_re *
ls_1(void *argp, CLIENT *clnt)
{
	static Ls_re clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, Ls,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_Ls_re, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

Fopen_re *
fopen_1(Fopen_s *argp, CLIENT *clnt)
{
	static Fopen_re clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, Fopen,
		(xdrproc_t) xdr_Fopen_s, (caddr_t) argp,
		(xdrproc_t) xdr_Fopen_re, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

Fclose_re *
fclose_1(Fclose_s *argp, CLIENT *clnt)
{
	static Fclose_re clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, Fclose,
		(xdrproc_t) xdr_Fclose_s, (caddr_t) argp,
		(xdrproc_t) xdr_Fclose_re, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

Fread_re *
fread_1(Fread_s *argp, CLIENT *clnt)
{
	static Fread_re clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, Fread,
		(xdrproc_t) xdr_Fread_s, (caddr_t) argp,
		(xdrproc_t) xdr_Fread_re, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

Fwrite_re *
fwrite_1(Fwrite_s *argp, CLIENT *clnt)
{
	static Fwrite_re clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, Fwrite,
		(xdrproc_t) xdr_Fwrite_s, (caddr_t) argp,
		(xdrproc_t) xdr_Fwrite_re, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

Flseek_re *
flseek_1(Flseek_s *argp, CLIENT *clnt)
{
	static Flseek_re clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, Flseek,
		(xdrproc_t) xdr_Flseek_s, (caddr_t) argp,
		(xdrproc_t) xdr_Flseek_re, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

Fcreate_re *
fcreate_1(Fcreate_s *argp, CLIENT *clnt)
{
	static Fcreate_re clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, Fcreate,
		(xdrproc_t) xdr_Fcreate_s, (caddr_t) argp,
		(xdrproc_t) xdr_Fcreate_re, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

Mkdir_re *
mkdir_1(Mkdir_s *argp, CLIENT *clnt)
{
	static Mkdir_re clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, Mkdir,
		(xdrproc_t) xdr_Mkdir_s, (caddr_t) argp,
		(xdrproc_t) xdr_Mkdir_re, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

Fdelete_re *
fdelete_1(Fdelete_s *argp, CLIENT *clnt)
{
	static Fdelete_re clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, Fdelete,
		(xdrproc_t) xdr_Fdelete_s, (caddr_t) argp,
		(xdrproc_t) xdr_Fdelete_re, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

Cd_re *
cd_1(Cd_s *argp, CLIENT *clnt)
{
	static Cd_re clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, Cd,
		(xdrproc_t) xdr_Cd_s, (caddr_t) argp,
		(xdrproc_t) xdr_Cd_re, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

Shutdown_re *
shutdown_1(void *argp, CLIENT *clnt)
{
	static Shutdown_re clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, Shutdown,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_Shutdown_re, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}
